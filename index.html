<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <link rel="icon" type="image/png" href="./apple-touch-icon.png">
    <link rel="apple-touch-icon" href="./apple-touch-icon.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AIå…¨èƒ½è¯†å­—åŠ©æ‰‹ (æœ€ç»ˆå®Œç¾ç‰ˆ)</title>
    
    <!-- 1. æ ·å¼åº“: Tailwind CSS (ä½¿ç”¨å®˜æ–¹æé€Ÿ CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React æ ¸å¿ƒåº“ (æœ¬åœ°æ–‡ä»¶ - æ°¸ä¹…æœ‰æ•ˆ) -->
    <script crossorigin src="./react.production.min.js"></script>
    <script crossorigin src="./react-dom.production.min.js"></script>
    
    <!-- 3. Babel ç¼–è¯‘å™¨ (æœ¬åœ°æ–‡ä»¶) -->
    <script src="./babel.min.js"></script>
    
    <!-- 4. åŠŸèƒ½æ’ä»¶ (æœ¬åœ°æ–‡ä»¶) -->
    <script src="./hanzi-writer.min.js"></script>
    <script src="https://code.responsivevoice.org/responsivevoice.js?key=bDKX5fqH"></script>
    <script src="./marked.min.js"></script>

    <style>
        /* å­—ä½“åŠ é€Ÿ: ä½¿ç”¨ loli.net (Google Fonts å›½å†…é•œåƒ) */
        @import url('https://fonts.loli.net/css2?family=Noto+Sans+SC:wght@400;700&display=swap');
        
        body { font-family: 'Noto Sans SC', sans-serif; background-color: #fff7ed; user-select: none; -webkit-tap-highlight-color: transparent; }
        .font-kaiti { font-family: "KaiTi", "STKaiti", "æ¥·ä½“", serif; }
        
        /* ç”°å­—æ ¼æ ¸å¿ƒæ ·å¼ */
        .tian-zi-ge {
            position: relative;
            background-color: #fff;
            border: 2px solid #ea580c;
            box-sizing: border-box;
            overflow: hidden;
        }
        .tian-zi-ge::before {
            content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 0;
            border-top: 1px dashed #fb923c; z-index: 0;
        }
        .tian-zi-ge::after {
            content: ''; position: absolute; left: 50%; top: 0; bottom: 0; width: 0;
            border-left: 1px dashed #fb923c; z-index: 0;
        }
        .tian-zi-ge-content { position: relative; z-index: 10; }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* åŠ¨ç”» */
        .mic-active { animation: pulse-red 1.5s infinite cubic-bezier(0.66, 0, 0, 1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
        @keyframes pulse-red { to { box-shadow: 0 0 0 20px rgba(239, 68, 68, 0); } }
        .wiggle { animation: wiggle 0.3s ease-in-out infinite; }
        @keyframes wiggle { 0%, 100% { transform: rotate(-1deg); } 50% { transform: rotate(1deg); } }
        
        .markdown-body strong { color: #ea580c; font-weight: 900; background: #ffedd5; padding: 0 4px; border-radius: 4px; }
        .markdown-body p { margin-bottom: 0.5em; line-height: 1.6; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- å›¾æ ‡ç»„ä»¶ ---
        const Icon = ({ name, size = 24, className }) => {
            const icons = {
                home: <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>,
                settings: <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.72l-.15.1a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.72l.15-.1a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path>,
                star: <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>,
                chat: <><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></>,
                mic: <><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></>,
                camera: <><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></>,
                sparkles: <path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"></path>,
                book: <><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></>,
                pen: <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>,
                arrowLeft: <><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></>,
                list: <><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></>,
                trash: <><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></>,
                edit: <><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></>,
                check: <polyline points="20 6 9 17 4 12"></polyline>,
                search: <><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></>,
                brain: <><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z"></path><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z"></path></>,
                x: <line x1="18" y1="6" x2="6" y2="18"></line>
            };
            return (
                <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                    {icons[name] || icons.home}
                    {name === 'x' && <line x1="6" y1="6" x2="18" y2="18"></line>}
                </svg>
            );
        };

        // âš ï¸ è¯­éŸ³æ’­æ”¾å‡çº§ï¼šæ”¯æŒæŒ‡å®šè¯­éŸ³æˆ–æ™ºèƒ½è‡ªåŠ¨
        const playAudio = (text, targetVoiceURI = 'auto', retryCount = 0) => {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const utter = new SpeechSynthesisUtterance(text);
                
                let voices = window.speechSynthesis.getVoices();
                
                // åˆ—è¡¨ä¸ºç©ºæ—¶çš„é‡è¯•æœºåˆ¶ (iOS å…³é”®ä¿®å¤)
                if (voices.length === 0) {
                    // å¦‚æœæ˜¯ç¬¬ 0 æ¬¡å°è¯•ï¼Œä¸”åˆ—è¡¨ä¸ºç©ºï¼Œä¸è¦æ­»ç­‰ï¼
                    // å°è¯•è§¦å‘ä¸€æ¬¡å¼‚æ­¥åŠ è½½ï¼ŒåŒæ—¶ç›´æ¥é™çº§æ’­æ”¾ï¼Œä¿è¯é€Ÿåº¦
                    if (retryCount === 0) {
                        // è§¦å‘åŠ è½½
                        window.speechSynthesis.onvoiceschanged = () => {
                            // ä¸‹æ¬¡æ’­æ”¾å°±èƒ½ç”¨ä¸Šæ–°åˆ—è¡¨äº†
                        };
                        // âš ï¸ å…³é”®ï¼šä¸ returnï¼Œç›´æ¥å¾€ä¸‹èµ°ï¼Œå°è¯•ç”¨é»˜è®¤é…ç½®ç›²æ’­
                    } else if (retryCount < 5) {
                        setTimeout(() => playAudio(text, targetVoiceURI, retryCount + 1), 100);
                        return;
                    }
                }


                let selectedVoice = null;

                // 1. ç²¾ç¡®åŒ¹é…ç”¨æˆ·é€‰æ‹©
                if (targetVoiceURI && targetVoiceURI !== 'auto') {
                    selectedVoice = voices.find(v => v.voiceURI === targetVoiceURI);
                }

                // 2. æ™ºèƒ½è‡ªåŠ¨é€‰æ‹© (Siri > TingTing > Google > Default)
                if (!selectedVoice) {
                    const zhVoices = voices.filter(v => v.lang.includes('zh'));
                    selectedVoice = zhVoices.find(v => v.name.includes('Siri') || v.name.includes('Enhanced'));
                    if (!selectedVoice) selectedVoice = zhVoices.find(v => v.name.includes('Ting-Ting') || v.name.includes('Google'));
                    if (!selectedVoice) selectedVoice = zhVoices[0];
                }

                if (selectedVoice) {
                    utter.voice = selectedVoice;
                    console.log("ğŸ”Š ä½¿ç”¨è¯­éŸ³:", selectedVoice.name); // è°ƒè¯•æ—¥å¿—
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                    utter.rate = isIOS ? 0.85 : 0.9; 
                    utter.pitch = 1.05; 
                }

                window.speechSynthesis.speak(utter);
            } else if (window.responsiveVoice) {
                window.responsiveVoice.speak(text, "Chinese Female", { rate: 0.85 });
            }
        };

        const compressImage = (file) => {
            return new Promise((resolve) => {
                const reader = new FileReader(); reader.readAsDataURL(file);
                reader.onload = (e) => {
                    const img = new Image(); img.src = e.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const MAX = 800; let w=img.width, h=img.height;
                        if(w>MAX){ h*=MAX/w; w=MAX; }
                        canvas.width=w; canvas.height=h;
                        canvas.getContext('2d').drawImage(img,0,0,w,h);
                        resolve(canvas.toDataURL('image/jpeg', 0.7).split(',')[1]);
                    };
                };
            });
        };

        // --- App ---
        function App() {
            const [mode, setMode] = useState('home'); 
            const [stars, setStars] = useState(() => parseInt(localStorage.getItem('app_stars') || '0'));
            const [apiKey, setApiKey] = useState(() => localStorage.getItem('gemini_key') || '');
            const [model, setModel] = useState(() => localStorage.getItem('gemini_model') || 'gemini-3-flash-preview');

            // 2. è¯­éŸ³é…ç½®çŠ¶æ€ (å…¨å±€æŒä¹…åŒ–)
            const [voiceURI, setVoiceURI] = useState(() => localStorage.getItem('app_voice_uri') || 'auto');

            // 3. å±å¹•å¸¸äº® Wake Lock (å…¨å±€)
            const wakeLockRef = useRef(null);
            useEffect(() => {
                const requestWakeLock = async () => {
                    try {
                        if ('wakeLock' in navigator) {
                            wakeLockRef.current = await navigator.wakeLock.request('screen');
                            console.log('âœ¨ å±å¹•å¸¸äº®å·²æ¿€æ´»');
                        }
                    } catch (err) { console.log('å¸¸äº®å¤±è´¥:', err); }
                };
                
                // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶é‡æ–°ç”³è¯·ï¼ˆä¾‹å¦‚åˆ‡åå°å›æ¥ï¼‰
                const handleVisibility = () => {
                    if (document.visibilityState === 'visible') requestWakeLock();
                };
                
                requestWakeLock();
                document.addEventListener('visibilitychange', handleVisibility);
                return () => {
                    document.removeEventListener('visibilitychange', handleVisibility);
                    if(wakeLockRef.current) wakeLockRef.current.release();
                };
            }, []);

            useEffect(() => localStorage.setItem('app_stars', stars), [stars]);
            useEffect(() => localStorage.setItem('app_voice_uri', voiceURI), [voiceURI]); // ä¿å­˜è¯­éŸ³é€‰æ‹©
            const addStar = () => setStars(s => s + 1);

            const callGemini = async (payload) => {
                if (!apiKey) return { error: "è¯·é…ç½® API Key" };
                try {
                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
                        { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }
                    );
                    const data = await response.json();
                    return data.error ? { error: data.error.message } : { text: data.candidates?.[0]?.content?.parts?.[0]?.text };
                } catch (error) { return { error: "ç½‘ç»œé”™è¯¯" }; }
            };

            return (
                <div className="min-h-screen flex flex-col w-full md:max-w-5xl mx-auto bg-orange-50 shadow-2xl relative overflow-hidden transition-all duration-300">
                    <header className="bg-white/90 backdrop-blur p-4 md:px-8 shadow-sm flex justify-between items-center z-50 sticky top-0">
                        <div className="flex items-center gap-3 cursor-pointer active:scale-95 transition-transform" onClick={() => setMode('home')}>
                            <div className="bg-orange-500 p-2 rounded-xl text-white shadow-orange-200 shadow-md"><Icon name="home" size={24} /></div>
                            <span className="font-bold text-slate-700 text-lg md:text-xl tracking-tight">AIå…¨èƒ½è¯†å­—</span>
                        </div>
                        <div className="flex items-center gap-4">
                            <div className="bg-yellow-100 text-yellow-700 px-4 py-1.5 rounded-full text-sm font-bold flex items-center gap-1.5 shadow-sm border border-yellow-200">
                                <Icon name="star" size={16} className="fill-yellow-500 text-yellow-500"/> <span className="pt-0.5">{stars}</span>
                            </div>
                            <button onClick={() => setMode('settings')} className="text-slate-400 hover:text-orange-500 p-2 hover:bg-orange-50 rounded-full transition-all"><Icon name="settings" size={24} /></button>
                        </div>
                    </header>
                    <div className="flex-1 overflow-hidden relative flex flex-col">
                        {mode === 'home' && <HomeView setMode={setMode} />}
                        {mode === 'settings' && <SettingsView apiKey={apiKey} setApiKey={setApiKey} model={model} setModel={setModel} voiceURI={voiceURI} setVoiceURI={setVoiceURI} onBack={() => setMode('home')} />}
                        {mode === 'learn' && <LearnMode callGemini={callGemini} addStar={addStar} voiceURI={voiceURI} onBack={() => setMode('home')} />}
                        {mode === 'dictation' && <DictationMode callGemini={callGemini} addStar={addStar} voiceURI={voiceURI} onBack={() => setMode('home')} />}
                    </div>
                </div>
            );
        }

        function HomeView({ setMode }) {
            return (
                <div className="flex flex-col h-full p-6 md:p-12 animate-in fade-in zoom-in-95 duration-300 overflow-y-auto">
                    <div className="text-center mt-4 md:mt-12 mb-10 md:mb-16">
                        <h1 className="text-3xl md:text-5xl font-bold text-slate-800 mb-3 md:mb-4 tracking-tight">å­¦ä¹ æ—¶é—´åˆ°ï¼</h1>
                        <p className="text-slate-400 text-sm md:text-lg">ä»Šå¤©ä¹Ÿè¦åšä¸ªæ£’æ£’çš„å°æœ‹å‹ ğŸˆ</p>
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 md:gap-8 w-full max-w-4xl mx-auto">
                        <button onClick={() => setMode('learn')} className="w-full relative overflow-hidden bg-white p-6 md:p-8 rounded-3xl shadow-lg border-b-4 border-orange-200 hover:-translate-y-1 hover:shadow-xl active:translate-y-0 active:border-b-0 active:shadow-md transition-all group flex md:flex-col md:items-start md:text-left items-center gap-4 md:gap-6">
                            <div className="w-16 h-16 md:w-20 md:h-20 bg-gradient-to-br from-orange-400 to-red-400 rounded-2xl flex items-center justify-center text-white shadow-lg text-3xl md:text-4xl group-hover:scale-110 transition-transform duration-300">ğŸ´</div>
                            <div className="text-left flex-1">
                                <h3 className="text-xl md:text-2xl font-bold text-slate-700 mb-1">è¯†å­—å¡ç‰‡</h3>
                                <p className="text-xs md:text-sm text-slate-400 leading-relaxed">è®¤å­— â€¢ ç¬”é¡º â€¢ AI ä¸¥è°¨è§£è¯´<br/>åŒ…å« ğŸ’¡ è¶£å‘³æˆè¯­è®²è§£</p>
                            </div>
                        </button>
                        <button onClick={() => setMode('dictation')} className="w-full relative overflow-hidden bg-white p-6 md:p-8 rounded-3xl shadow-lg border-b-4 border-blue-200 hover:-translate-y-1 hover:shadow-xl active:translate-y-0 active:border-b-0 active:shadow-md transition-all group flex md:flex-col md:items-start md:text-left items-center gap-4 md:gap-6">
                            <div className="w-16 h-16 md:w-20 md:h-20 bg-gradient-to-br from-blue-400 to-indigo-400 rounded-2xl flex items-center justify-center text-white shadow-lg text-3xl md:text-4xl group-hover:scale-110 transition-transform duration-300">ğŸ“</div>
                            <div className="text-left flex-1">
                                <h3 className="text-xl md:text-2xl font-bold text-slate-700 mb-1">å¬å†™ç»ƒä¹ </h3>
                                <p className="text-xs md:text-sm text-slate-400 leading-relaxed">è¯­éŸ³æŠ¥è¯ â€¢ æ‹ç…§æ™ºèƒ½æ‰¹æ”¹<br/>æ”¯æŒ ğŸ“¸ æ‹ç…§ä¸€é”®å¯¼å…¥è¯åº“</p>
                            </div>
                        </button>
                    </div>
                </div>
            );
        }

        function SettingsView({ apiKey, setApiKey, model, setModel, voiceURI, setVoiceURI, onBack }) {
            const [k, setK] = useState(apiKey);
            const [m, setM] = useState(model);
            const [vURI, setVURI] = useState(voiceURI); // æœ¬åœ°çŠ¶æ€
            const [isCustom, setIsCustom] = useState(false);
            const [customModel, setCustomModel] = useState('');
            const [voiceList, setVoiceList] = useState([]);

            useEffect(() => {
                const loadVoices = () => {
                    const vs = window.speechSynthesis.getVoices().filter(v => v.lang.includes('zh'));
                    setVoiceList(vs);
                };
                loadVoices();
                window.speechSynthesis.onvoiceschanged = loadVoices;
            }, []);

            useEffect(() => {
                const defaults = ['gemini-3-flash-preview', 'gemini-3-pro-preview', 'gemini-2.0-flash-exp'];
                if (defaults.includes(model)) { setIsCustom(false); } 
                else { setIsCustom(true); setCustomModel(model); setM('custom'); }
            }, []);

            const save = () => { 
                const finalModel = isCustom ? customModel.trim() : m;
                if (!finalModel) { alert("æ¨¡å‹åç§°ä¸èƒ½ä¸ºç©º"); return; }
                setApiKey(k); setModel(finalModel); setVoiceURI(vURI); // ä¿å­˜è¯­éŸ³
                localStorage.setItem('gemini_key', k); localStorage.setItem('gemini_model', finalModel); 
                alert("ä¿å­˜æˆåŠŸ âœ…"); onBack(); 
            };

            return (
                <div className="p-6 h-full bg-white animate-in slide-in-from-right overflow-y-auto">
                    <h2 className="text-xl font-bold mb-6 text-slate-700">ç³»ç»Ÿè®¾ç½®</h2>
                    <div className="space-y-6">
                        {/* API è®¾ç½® */}
                        <div className="space-y-4">
                            <div><label className="text-sm font-bold text-slate-600">Gemini API Key</label><input type="password" value={k} onChange={e=>setK(e.target.value)} className="w-full p-3 bg-slate-50 border rounded-xl mt-1 text-sm font-mono focus:border-orange-500 outline-none" placeholder="AIzaSy..."/></div>
                            <div><label className="text-sm font-bold text-slate-600">AI æ¨¡å‹ <span className="text-[10px] bg-red-500 text-white px-1 rounded ml-1">NEW</span></label>
                                <select value={m} onChange={e => { setM(e.target.value); setIsCustom(e.target.value === 'custom'); }} className="w-full p-3 bg-slate-50 border rounded-xl mt-1 focus:border-orange-500 outline-none">
                                    <option value="gemini-3-flash-preview">Gemini 3 Flash Preview (æé€Ÿ)</option>
                                    <option value="gemini-3-pro-preview">Gemini 3 Pro Preview (è¶…å¼º)</option>
                                    <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash Exp</option>
                                    <option value="custom">è‡ªå®šä¹‰ (è¾“å…¥æ¨¡å‹ID)</option>
                                </select>
                                {isCustom && <input type="text" value={customModel} onChange={e => setCustomModel(e.target.value)} className="w-full p-3 mt-2 bg-indigo-50 border border-indigo-200 text-indigo-700 rounded-xl text-sm font-mono placeholder-indigo-300" placeholder="ä¾‹å¦‚: gemini-2.0-flash-lite"/>}
                            </div>
                        </div>

                        {/* è¯­éŸ³è®¾ç½® */}
                        <div>
                            <label className="text-sm font-bold text-slate-600 mb-2 block">å¬å†™/æœ—è¯»è¯­éŸ³</label>
                            <div className="bg-slate-50 p-4 rounded-xl border border-slate-100">
                                <select value={vURI} onChange={e => { setVURI(e.target.value); playAudio("è¯­éŸ³å·²åˆ‡æ¢", e.target.value); }} className="w-full p-3 bg-white border rounded-xl focus:border-orange-500 outline-none mb-3 text-slate-700 font-medium shadow-sm">
                                    <option value="auto">âœ¨ æ™ºèƒ½æ¨è (Auto)</option>
                                    {voiceList.map((v, i) => (
                                        <option key={i} value={v.voiceURI}>{v.name} {v.localService?'[æœ¬åœ°]':''}</option>
                                    ))}
                                </select>
                                <div className="text-xs text-slate-400 leading-relaxed">
                                    {vURI === 'auto' 
                                        ? "å½“å‰æ¨¡å¼ï¼šè‡ªåŠ¨ä¼˜å…ˆä½¿ç”¨ Siriã€Ting-Ting æˆ– Google é«˜è´¨é‡è¯­éŸ³ã€‚" 
                                        : "å½“å‰æ¨¡å¼ï¼šå·²é”å®šä¸ºä½ é€‰æ‹©çš„ç‰¹å®šè¯­éŸ³ã€‚"}
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="flex gap-4 mt-8 pb-8"><button onClick={onBack} className="flex-1 py-3 bg-slate-100 rounded-xl font-bold text-slate-500">å–æ¶ˆ</button><button onClick={save} className="flex-1 py-3 bg-orange-500 text-white rounded-xl font-bold shadow-lg shadow-orange-200">ä¿å­˜</button></div>
                </div>
            );
        }

        // --- è¯†å­—æ¨¡å¼ (å¢å¼ºç‰ˆ) ---
        function LearnMode({ callGemini, addStar, onBack }) {
            const [cards, setCards] = useState(() => JSON.parse(localStorage.getItem('hanzi_cards')) || [{id:1,hanzi:'çˆ¸',pinyin:'bÃ '},{id:2,hanzi:'å¦ˆ',pinyin:'mÄ'}]);
            const [view, setView] = useState('gallery'); 
            const [curIdx, setCurIdx] = useState(0);
            const [aiStatus, setAiStatus] = useState('idle');
            const [aiResult, setAiResult] = useState('');
            const [batchModal, setBatchModal] = useState(false);
            const [batchText, setBatchText] = useState('');
            const [isWriting, setIsWriting] = useState(false); 
            const [isEditing, setIsEditing] = useState(false);
            
            const [storyModal, setStoryModal] = useState(false);
            const [storyContent, setStoryContent] = useState('');
            const [isStoryLoading, setIsStoryLoading] = useState(false);

            // --- æ–°å¢ï¼šAI èŠå¤©çŠ¶æ€ ---
            const [chatMode, setChatMode] = useState(false);
            const [chatHistory, setChatHistory] = useState([]);
            const [chatInput, setChatInput] = useState('');
            const chatBoxRef = useRef(null);

            const writerRef = useRef(null);

            useEffect(() => localStorage.setItem('hanzi_cards', JSON.stringify(cards)), [cards]);

            useEffect(() => {
                setIsWriting(false); setAiResult(''); setChatMode(false); setChatHistory([]); // åˆ‡æ¢å­—æ—¶é‡ç½®èŠå¤©
                const target = document.getElementById('hanzi-target'); if(target) target.innerHTML = '';
            }, [curIdx]);

            // --- AI èŠå¤©é€»è¾‘ ---
            const [isRecording, setIsRecording] = useState(false);
            const chatRecognitionRef = useRef(null);

            useEffect(() => {
                // åˆå§‹åŒ–è¯­éŸ³è¯†åˆ«
                if ('webkitSpeechRecognition' in window) {
                    const r = new webkitSpeechRecognition();
                    r.continuous = false; 
                    r.lang = 'zh-CN';
                    r.interimResults = true; // å®æ—¶æ˜¾ç¤ºç»“æœ
                    
                    r.onstart = () => setIsRecording(true);
                    r.onend = () => setIsRecording(false);
                    r.onresult = (e) => {
                        const transcript = Array.from(e.results)
                            .map(result => result[0])
                            .map(result => result.transcript)
                            .join('');
                        setChatInput(transcript); // å®æ—¶ä¸Šå±
                        
                        // å¦‚æœæ˜¯æœ€ç»ˆç»“æœï¼Œä¸”ä¸ä¸ºç©ºï¼Œå¯ä»¥é€‰æ‹©è‡ªåŠ¨å‘é€ï¼ˆè¿™é‡Œä¸ºäº†ç¡®è®¤å‡†ç¡®ï¼Œæš‚ä¸è‡ªåŠ¨å‘é€ï¼‰
                        // if (e.results[0].isFinal) { ... }
                    };
                    chatRecognitionRef.current = r;
                }
                return () => { if(chatRecognitionRef.current) chatRecognitionRef.current.abort(); };
            }, []);

            const toggleVoiceInput = () => {
                if (!chatRecognitionRef.current) { alert("æŠ±æ­‰ï¼Œæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¾“å…¥"); return; }
                
                if (isRecording) {
                    chatRecognitionRef.current.stop();
                } else {
                    setChatInput(''); // æ¸…ç©ºä¹‹å‰çš„
                    chatRecognitionRef.current.start();
                }
            };

            const handleStartChat = () => {
                setChatMode(true);
                const char = cards[curIdx].hanzi;
                // åˆå§‹æ¬¢è¿è¯­
                setChatHistory([{
                    role: 'ai', 
                    content: `ä½ å¥½å‘€ï¼æˆ‘æ˜¯æ±‰å­—â€œ${char}â€ã€‚ä½ æƒ³é—®æˆ‘ä»€ä¹ˆé—®é¢˜å—ï¼Ÿæ¯”å¦‚â€œä½ ä¸ºä»€ä¹ˆé•¿è¿™ä¸ªæ ·å­ï¼Ÿâ€æˆ–è€…â€œä½ å¯ä»¥ç»„ä»€ä¹ˆè¯ï¼Ÿâ€`
                }]);
            };

            const handleSendMessage = async () => {
                if(!chatInput.trim()) return;
                const char = cards[curIdx].hanzi;
                const userMsg = chatInput;
                setChatInput('');
                setChatHistory(prev => [...prev, {role: 'user', content: userMsg}, {role: 'ai', content: '...', loading: true}]);
                
                // æ»šåŠ¨åˆ°åº•éƒ¨
                setTimeout(() => chatBoxRef.current?.scrollTo({top: 9999, behavior: 'smooth'}), 100);

                const prompt = `ä½ ç°åœ¨å¿…é¡»æ‰®æ¼”æ±‰å­—â€œ${char}â€ã€‚
ä½ çš„æ€§æ ¼ï¼šæ´»æ³¼ã€å¯çˆ±ã€åƒä¸ªè€æœ‹å‹ã€‚
ç”¨æˆ·ï¼ˆ5å²å°æœ‹å‹ï¼‰é—®ä½ ï¼šâ€œ${userMsg}â€
è¯·ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€æ¥å›ç­”ã€‚ç­”æ¡ˆè¦ç®€çŸ­ï¼ˆ50å­—ä»¥å†…ï¼‰ï¼Œå……æ»¡ç«¥è¶£ã€‚
ä¸è¦è¯´æ•™ï¼Œè¦å¥½ç©ã€‚`;

                const res = await callGemini({ contents: [{ parts: [{ text: prompt }] }] });
                
                setChatHistory(prev => {
                    const newHist = [...prev];
                    newHist.pop(); // ç§»é™¤ loading
                    if(res.text) {
                        newHist.push({role: 'ai', content: res.text});
                        playAudio(res.text); // è‡ªåŠ¨æœ—è¯»å›å¤
                    } else {
                        newHist.push({role: 'ai', content: "å“å‘€ï¼Œæˆ‘åˆšæ‰èµ°ç¥äº†ï¼Œæ²¡å¬æ¸…ä½ è¯´ä»€ä¹ˆ..."});
                    }
                    return newHist;
                });
                setTimeout(() => chatBoxRef.current?.scrollTo({top: 9999, behavior: 'smooth'}), 100);
            };

            const renderWriter = () => {
                const target = document.getElementById('hanzi-target');
                if(!target) return;
                setIsWriting(true); target.innerHTML = ''; 
                writerRef.current = HanziWriter.create('hanzi-target', cards[curIdx].hanzi, {
                    width: 260, height: 260, padding: 5, strokeColor: '#334155', radicalColor: '#ea580c', showOutline: true
                });
                writerRef.current.animateCharacter();
            };

            const handleExplain = async () => {
                setAiStatus('loading'); setAiResult('');
                const char = cards[curIdx].hanzi;
                const prompt = `ä½ æ˜¯ä¸€ä¸ªä¸¥è°¨çš„è¯­æ–‡è€å¸ˆã€‚è¯·ç»™5å²å­©å­è§£é‡Šæ±‰å­—â€œ${char}â€ã€‚
è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹ JSON æ ¼å¼è¿”å›ï¼Œä¸è¦åŒ…å« markdown ä»£ç å—æ ‡è®°ï¼š
{
  "explanation": "ä¸€å¥å……æ»¡ç«¥è¶£çš„è§£é‡Š",
  "idioms": [
    {"word": "æˆè¯­1", "meaning": "ç®€å•å¥½æ‡‚çš„æ„æ€"},
    {"word": "æˆè¯­2", "meaning": "ç®€å•å¥½æ‡‚çš„æ„æ€"}
  ]
}
é‡è¦è§„åˆ™ï¼š
1. è¿”å›çš„æˆè¯­å¿…é¡»åŒ…å«æ±‰å­—â€œ${char}â€ï¼Œä¸¥ç¦ä½¿ç”¨åŒéŸ³å­—æˆ–å½¢è¿‘å­—ã€‚
2. è§£é‡Šè¦é€‚åˆ5å²å­©å­å¬ã€‚
3. å¦‚æœæ‰¾ä¸åˆ°åˆé€‚çš„æˆè¯­ï¼Œidioms æ•°ç»„ç•™ç©ºã€‚`;
                
                const res = await callGemini({ contents: [{ parts: [{ text: prompt }] }] });
                setAiStatus('idle');
                if(res.text) {
                    try {
                        const cleanJson = res.text.replace(/```json|```/g, '').trim();
                        const data = JSON.parse(cleanJson);
                        const validIdioms = data.idioms.filter(item => item.word.includes(char));
                        
                        let displayHtml = `<div class="space-y-4"><div><span class="text-orange-500 font-bold">ğŸ’¡ æ„æ€ï¼š</span><span class="text-slate-700">${data.explanation}</span></div>`;
                        if (validIdioms.length > 0) {
                            displayHtml += `<div><div class="text-orange-500 font-bold mb-1">ğŸ“– æˆè¯­å­¦ä¹ ï¼š</div><div class="space-y-2">`;
                            validIdioms.forEach(item => {
                                displayHtml += `<div class="bg-orange-50 p-2 rounded-lg border border-orange-100"><span class="font-bold text-slate-800 text-lg">ã€${item.word}ã€‘</span><div class="text-slate-600 text-xs mt-1 leading-relaxed">${item.meaning}</div></div>`;
                            });
                            displayHtml += `</div></div>`;
                        }
                        displayHtml += `</div>`;
                        setAiResult(displayHtml);
                        let speakText = `æ„æ€æ˜¯ï¼š${data.explanation}ã€‚`;
                        if (validIdioms.length > 0) speakText += `æˆè¯­æœ‰ï¼š${validIdioms.map(i => i.word + "ï¼Œ" + i.meaning).join("ã€‚")}`;
                        playAudio(speakText);
                    } catch (e) {
                        setAiResult(`<div class="p-2 text-slate-600">${res.text}</div>`);
                        playAudio(res.text);
                    }
                }
            };

            const handleSimilar = async () => {
                setAiStatus('loading'); setAiResult('');
                const char = cards[curIdx].hanzi;
                const prompt = `è¯·æ‰¾å‡º2-3ä¸ªå®¹æ˜“å’Œæ±‰å­—â€œ${char}â€æ··æ·†çš„å½¢è¿‘å­—æˆ–éŸ³è¿‘å­—ã€‚è¯·ç”¨ç®€å•æ˜“æ‡‚çš„è¯­è¨€å‘Šè¯‰5å²å­©å­æ€ä¹ˆåŒºåˆ†å®ƒä»¬ã€‚è¯·ä½¿ç”¨Markdownæ ¼å¼ï¼Œé‡ç‚¹æ–‡å­—åŠ ç²—ã€‚`;
                const res = await callGemini({ contents: [{ parts: [{ text: prompt }] }] });
                setAiStatus('idle');
                if(res.text) { 
                    setAiResult(`<div class="markdown-body text-xs leading-relaxed">${marked.parse(res.text)}</div>`); 
                    const speakText = res.text.replace(/[*#`_~\[\]]/g, ''); 
                    playAudio(speakText);
                }
            };

            const handleGenerateStory = async () => {
                if(cards.length === 0) return;
                setIsStoryLoading(true); setStoryModal(true); setStoryContent('');
                const shuffled = [...cards].sort(() => 0.5 - Math.random());
                const selected = shuffled.slice(0, 8).map(c => c.hanzi);
                const prompt = `è¯·ç”¨ä»¥ä¸‹è¿™äº›æ±‰å­—ç¼–ä¸€ä¸ªé€‚åˆ5å²å°æœ‹å‹å¬çš„çŸ­ç«¥è¯æ•…äº‹ï¼ˆ150å­—ä»¥å†…ï¼‰ï¼š${selected.join('ï¼Œ')}ã€‚
                è¦æ±‚ï¼š1. æ•…äº‹æƒ…èŠ‚æœ‰è¶£ã€æœ‰åè½¬ã€‚2. å¿…é¡»ç”¨åˆ°ä¸Šé¢æä¾›çš„å­—ã€‚3. å°†ç”¨åˆ°çš„è¿™äº›å­—ç”¨ **åŠ ç²—** æ ‡è®°å‡ºæ¥ã€‚4. æœ€åç»™æ•…äº‹èµ·ä¸ªå¯çˆ±çš„åå­—ã€‚`;
                const res = await callGemini({ contents: [{ parts: [{ text: prompt }] }] });
                setIsStoryLoading(false);
                if(res.text) { 
                    setStoryContent(res.text); 
                    const title = res.text.split('\n')[0].replace(/[#*]/g, '');
                    playAudio(`æ•…äº‹æ—¶é—´ï¼š${title}`);
                }
            };

            const handlePhotoAdd = async (e) => {
                const file = e.target.files[0]; if(!file) return;
                setAiStatus('loading');
                const base64 = await compressImage(file);
                const prompt = `è¯·è¯†åˆ«å›¾ç‰‡ä¸­æ‰€æœ‰çš„ç®€ä½“ä¸­æ–‡å­—ç¬¦ï¼ˆä¸åŒ…å«æ ‡ç‚¹ç¬¦å·ï¼‰ã€‚è¯·è¿”å›ä¸€ä¸ª JSON æ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡åŒ…å« "hanzi" (æ±‰å­—) å’Œ "pinyin" (æ‹¼éŸ³å¸¦å£°è°ƒ)ã€‚ä¾‹å¦‚: [{"hanzi": "çˆ¸", "pinyin": "bÃ "}]`;
                const res = await callGemini({ contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: "image/jpeg", data: base64 } }] }] });
                setAiStatus('idle');
                try {
                    const cleanJson = res.text.replace(/```json|```/g, '').trim();
                    const list = JSON.parse(cleanJson);
                    if (Array.isArray(list)) {
                        const existingChars = new Set(cards.map(c => c.hanzi));
                        const newItems = list.filter(item => !existingChars.has(item.hanzi));
                        if (newItems.length > 0) {
                            const itemsToAdd = newItems.map(i => ({id: Date.now() + Math.random(), ...i}));
                            setCards(prev => [...prev, ...itemsToAdd]);
                            alert(`âœ… æˆåŠŸæ·»åŠ  ${newItems.length} ä¸ªæ–°å­—ï¼\n(å·²è¿‡æ»¤ ${list.length - newItems.length} ä¸ªé‡å¤å­—)`);
                        } else { alert("ğŸ‘€ å›¾ç‰‡é‡Œçš„å­—å¥½åƒéƒ½å­¦è¿‡äº†å“¦ï¼(å…¨éƒ¨é‡å¤)"); }
                    }
                } catch (e) { alert("è¯†åˆ«å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚"); }
            };

            const handleBatchImport = async () => {
                if(!batchText) return;
                setAiStatus('loading');
                const inputChars = batchText.replace(/[^\u4e00-\u9fa5]/g, '').split('').filter((v,i,a)=>a.indexOf(v)===i);
                const existingChars = new Set(cards.map(c => c.hanzi));
                const newChars = inputChars.filter(char => !existingChars.has(char));

                if (newChars.length === 0) {
                    setAiStatus('idle');
                    alert("æ‚¨è¾“å…¥çš„å­—éƒ½å·²ç»å­¦è¿‡äº†å“¦ï¼");
                    return;
                }

                const prompt = `Give pinyin for chars: ${newChars.join('')}. Return JSON array: [{"hanzi":"å­—","pinyin":"py"}]`;
                const res = await callGemini({ contents: [{ parts: [{ text: prompt }] }] });
                setAiStatus('idle');
                
                try {
                    const list = JSON.parse(res.text.replace(/```json|```/g, '').trim());
                    const newCards = list.map(i=>({id: Date.now() + Math.random(), ...i}));
                    setCards(prev => [...prev, ...newCards]);
                    setBatchModal(false); setBatchText(''); 
                    alert(`æˆåŠŸæ·»åŠ  ${newCards.length} ä¸ªæ–°å­—ï¼\n(è‡ªåŠ¨è¿‡æ»¤äº† ${inputChars.length - newChars.length} ä¸ªé‡å¤å­—)`);
                } catch(e) {
                     const newCards = newChars.map(c=>({id: Date.now() + Math.random(), hanzi:c, pinyin:''}));
                     setCards(prev => [...prev, ...newCards]);
                     setBatchModal(false);
                }
            };
            
            const deleteCard = (e, id) => {
                e.stopPropagation(); 
                if(confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå­—å—ï¼Ÿ")) {
                    setCards(prev => prev.filter(c => c.id !== id));
                    if(view === 'card' && cards[curIdx]?.id === id) setView('gallery');
                }
            };

            const updatePinyin = (id, newPinyin) => {
                setCards(cards.map(c => c.id === id ? { ...c, pinyin: newPinyin } : c));
            };

            if(view === 'gallery') return (
                <div className="h-full flex flex-col p-4 md:p-8 animate-in fade-in relative overflow-hidden">
                    <div className="flex justify-between items-center mb-6">
                        <button onClick={onBack} className="text-slate-500 font-bold flex items-center gap-2 hover:text-slate-700 transition-colors"><div className="bg-white p-2 rounded-full shadow-sm"><Icon name="arrowLeft" size={20}/></div> è¿”å›é¦–é¡µ</button>
                        <div className="flex gap-3">
                             <button onClick={() => setIsEditing(!isEditing)} className={`px-4 py-2 rounded-xl text-sm font-bold flex items-center gap-2 transition-all shadow-sm ${isEditing ? 'bg-red-500 text-white shadow-red-200' : 'bg-white text-slate-600 hover:bg-slate-50'}`}>{isEditing ? <><Icon name="check" size={18}/> å®Œæˆ</> : <><Icon name="edit" size={18}/> ç®¡ç†</>}</button>
                             <button onClick={() => setView('list')} className="bg-white text-slate-600 px-4 py-2 rounded-xl text-sm font-bold flex items-center gap-2 hover:bg-slate-50 shadow-sm"><Icon name="list" size={18}/> åˆ—è¡¨</button>
                        </div>
                    </div>
                    
                    <div className="mb-6">
                         <button onClick={handleGenerateStory} className="w-full bg-gradient-to-r from-pink-500 to-purple-500 text-white p-4 md:p-6 rounded-2xl shadow-lg shadow-pink-200 flex items-center justify-center gap-3 font-bold active:scale-95 hover:shadow-xl transition-all group">
                             <div className="bg-white/20 p-2 rounded-full group-hover:rotate-12 transition-transform"><Icon name="book" size={24}/></div>
                             <span className="text-lg">AI åˆ›æ„ç»˜æœ¬ (ç”¨ç”Ÿå­—è®²æ•…äº‹)</span>
                         </button>
                    </div>

                    <div className="flex-1 overflow-y-auto no-scrollbar grid grid-cols-3 md:grid-cols-5 lg:grid-cols-6 gap-4 md:gap-6 pb-24 content-start">
                        {cards.map((c, i) => (
                            <div key={c.id} onClick={() => {if(!isEditing) {setCurIdx(i); setView('card');}}} className={`aspect-square bg-white rounded-2xl shadow-sm border-2 flex flex-col items-center justify-center font-kaiti text-3xl md:text-4xl text-slate-700 relative transition-all group cursor-pointer ${isEditing ? 'shake border-red-200' : 'border-slate-100 hover:border-orange-200 hover:shadow-md active:scale-95'}`}>
                                <span className="text-xs md:text-sm font-sans text-slate-300 mb-1 group-hover:text-orange-300 transition-colors">{c.pinyin}</span>{c.hanzi}
                                {isEditing && <button onClick={(e) => deleteCard(e, c.id)} className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-2 shadow-md z-20 animate-in zoom-in hover:bg-red-600 transition-colors"><Icon name="trash" size={14}/></button>}
                            </div>
                        ))}
                        <label className="aspect-square bg-indigo-50 border-2 border-dashed border-indigo-200 rounded-2xl flex flex-col items-center justify-center text-indigo-400 cursor-pointer active:bg-indigo-100 hover:border-indigo-400 hover:text-indigo-500 transition-all">
                             {aiStatus === 'loading' ? <span className="animate-spin text-3xl">â³</span> : <Icon name="camera" size={36}/>}
                             <span className="text-xs md:text-sm font-bold mt-2">æ‹ç…§åŠ å­—</span>
                             <input type="file" className="hidden" accept="image/*" onChange={handlePhotoAdd} />
                        </label>
                        <div onClick={() => setBatchModal(true)} className="aspect-square bg-slate-50 border-2 border-dashed border-slate-200 rounded-2xl flex flex-col items-center justify-center text-slate-400 cursor-pointer active:bg-slate-100 hover:border-slate-400 hover:text-slate-500 transition-all">
                             <span className="text-3xl mb-1">+</span><span className="text-xs md:text-sm font-bold">æ‰‹åŠ¨/æ‰¹é‡</span>
                        </div>
                    </div>

                    {storyModal && (
                        <div className="absolute inset-0 bg-white z-50 flex flex-col animate-in slide-in-from-bottom">
                            <div className="p-4 border-b flex justify-between items-center bg-pink-50">
                                <h3 className="font-bold text-pink-600 flex items-center gap-2"><Icon name="sparkles" size={18}/> AI æ•…äº‹ä¼š</h3>
                                <button onClick={() => setStoryModal(false)} className="bg-white p-2 rounded-full shadow text-slate-400"><Icon name="x" size={20}/></button>
                            </div>
                            <div className="flex-1 p-6 overflow-y-auto">
                                {isStoryLoading ? (
                                    <div className="flex flex-col items-center justify-center h-full text-pink-400 space-y-4">
                                        <div className="animate-spin text-4xl">âœ¨</div>
                                        <p>æ­£åœ¨æŠŠç”Ÿå­—å˜æˆæ•…äº‹...</p>
                                    </div>
                                ) : (
                                    <div className="markdown-body text-slate-700 leading-relaxed font-kaiti text-lg" dangerouslySetInnerHTML={{__html: marked.parse(storyContent)}}></div>
                                )}
                            </div>
                            {!isStoryLoading && (
                                <div className="p-4 border-t flex justify-center">
                                     <button onClick={() => playAudio(storyContent.replace(/[#*]/g, ''))} className="bg-pink-500 text-white px-6 py-3 rounded-full font-bold shadow-lg flex items-center gap-2 active:scale-95"><Icon name="mic" size={20}/> æœ—è¯»æ•…äº‹</button>
                                </div>
                            )}
                        </div>
                    )}

                    {batchModal && <div className="absolute inset-0 bg-black/50 z-50 flex items-center justify-center p-4"><div className="bg-white rounded-2xl p-6 w-full"><h3 className="font-bold mb-2">è¾“å…¥æ±‰å­—</h3><textarea value={batchText} onChange={e=>setBatchText(e.target.value)} className="w-full border p-2 h-24 rounded-xl mb-4 text-lg" placeholder="å¤©åœ°ç„é»„..."></textarea><div className="flex justify-end gap-2"><button onClick={()=>setBatchModal(false)} className="px-4 py-2 text-slate-500 font-bold">å–æ¶ˆ</button><button onClick={handleBatchImport} className="px-4 py-2 bg-indigo-500 text-white rounded-lg font-bold shadow">{aiStatus==='loading'?'...':'ç¡®å®š'}</button></div></div></div>}
                </div>
            );

            if(view === 'list') return (
                <div className="h-full flex flex-col p-4 md:p-8 bg-slate-50 animate-in slide-in-from-right relative z-20">
                    <div className="flex justify-between items-center mb-6 max-w-4xl mx-auto w-full">
                        <button onClick={() => setView('gallery')} className="text-slate-500 font-bold flex items-center gap-2 hover:text-slate-700"><div className="bg-white p-2 rounded-full shadow-sm"><Icon name="arrowLeft" size={20}/></div> è¿”å›ç”»å»Š</button>
                        <span className="text-sm font-bold text-slate-400 bg-white px-3 py-1 rounded-full border">å…± {cards.length} ä¸ªå­—</span>
                    </div>
                    <div className="flex-1 overflow-y-auto no-scrollbar pb-8 max-w-4xl mx-auto w-full">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                        {cards.map((card) => (
                            <div key={card.id} className="flex items-center gap-4 bg-white p-4 rounded-xl border border-slate-100 shadow-sm hover:shadow-md transition-shadow">
                                <div className="w-14 h-14 bg-orange-50 rounded-xl flex items-center justify-center text-3xl font-bold text-slate-700 font-kaiti border border-orange-100">{card.hanzi}</div>
                                <div className="flex-1">
                                    <div className="text-xs text-slate-400 mb-1">æ‹¼éŸ³ä¿®æ­£</div>
                                    <input type="text" value={card.pinyin} onChange={(e) => updatePinyin(card.id, e.target.value)} className="w-full bg-slate-50 border-b border-transparent focus:border-orange-400 outline-none px-2 py-1 text-slate-700 font-mono rounded text-lg"/>
                                </div>
                                <button onClick={(e) => deleteCard(e, card.id)} className="p-3 text-slate-300 hover:text-red-500 hover:bg-red-50 rounded-xl transition-colors"><Icon name="trash" size={20} /></button>
                            </div>
                        ))}
                        </div>
                    </div>
                </div>
            );

            return (
                <div className="h-full flex flex-col p-4 md:p-8 relative">
                    {/* Header */}
                    <div className="w-full flex justify-between items-center mb-4 md:mb-0">
                        <button onClick={() => setView('gallery')} className="p-3 bg-white rounded-xl shadow-sm hover:shadow text-slate-500 transition-all"><Icon name="home" size={20}/></button>
                        <span className="text-sm font-bold text-slate-300 bg-white/50 px-3 py-1 rounded-full md:hidden">{curIdx+1}/{cards.length}</span>
                        <button onClick={(e) => deleteCard(e, cards[curIdx].id)} className="p-3 bg-red-50 text-red-400 rounded-xl shadow-sm hover:bg-red-100 transition-all"><Icon name="trash" size={20}/></button>
                    </div>

                    {/* Main Content Area: Responsive Split */}
                    <div className="flex-1 w-full flex flex-col md:flex-row items-center md:items-start md:justify-center gap-6 md:gap-12 mt-2 md:mt-8 overflow-hidden">
                        
                        {/* Left Column: TianZiGe & Nav */}
                        <div className="flex flex-col items-center gap-6 relative z-10 shrink-0">
                            <div className="tian-zi-ge rounded-[2.5rem] shadow-2xl aspect-[3/4] flex flex-col items-center relative transition-all bg-white w-[80vw] max-w-xs md:w-96 md:h-[32rem]">
                                <div className="mt-8 md:mt-12 text-6xl md:text-7xl font-mono font-bold text-orange-400 tian-zi-ge-content tracking-wider">{cards[curIdx].pinyin}</div>
                                <div className="flex-1 w-full flex items-center justify-center relative cursor-pointer tian-zi-ge-content" onClick={() => playAudio(cards[curIdx].hanzi)}>
                                    <div id="hanzi-target"></div>
                                    {!isWriting && <div className="text-[200px] md:text-[240px] font-kaiti font-bold text-slate-800 absolute inset-0 flex items-center justify-center pointer-events-none pb-4 select-none">{cards[curIdx].hanzi}</div>}
                                </div>
                            </div>
                            
                            <div className="flex gap-12 text-slate-300">
                                <button onClick={()=>{setCurIdx((i)=>(i-1+cards.length)%cards.length)}} className="p-4 bg-white rounded-full shadow-lg hover:bg-orange-50 hover:text-orange-400 active:scale-95 transition-all"><Icon name="arrowLeft" size={28}/></button>
                                <div className="hidden md:flex flex-col items-center justify-center text-xs font-bold text-slate-300">
                                    <span>{curIdx+1}</span>
                                    <div className="w-8 h-1 bg-slate-200 rounded-full my-1"></div>
                                    <span>{cards.length}</span>
                                </div>
                                <button onClick={()=>{setCurIdx((i)=>(i+1)%cards.length)}} className="p-4 bg-white rounded-full shadow-lg hover:bg-orange-50 hover:text-orange-400 active:scale-95 transition-all"><Icon name="arrowLeft" size={28} className="rotate-180"/></button>
                            </div>
                        </div>

                        {/* Right Column: Controls & AI Result */}
                        <div className="w-full max-w-sm md:max-w-md md:h-[32rem] md:flex md:flex-col gap-4 relative">
                            {/* Action Buttons Grid */}
                            {!chatMode ? (
                                <div className="grid grid-cols-4 md:grid-cols-2 gap-3 md:gap-4 shrink-0">
                                    <button onClick={renderWriter} className="flex flex-col md:flex-row items-center justify-center md:gap-3 h-16 md:h-20 bg-green-500 text-white rounded-2xl shadow-lg shadow-green-200 active:scale-95 transition-transform hover:bg-green-600">
                                        <Icon name="pen" size={24}/>
                                        <span className="text-[10px] md:text-base font-bold mt-1 md:mt-0">å†™ä¸€å†™</span>
                                    </button>
                                    <button onClick={() => playAudio(cards[curIdx].hanzi)} className="flex flex-col md:flex-row items-center justify-center md:gap-3 h-16 md:h-20 bg-orange-500 text-white rounded-2xl shadow-lg shadow-orange-200 active:scale-95 transition-transform hover:bg-orange-600">
                                        <Icon name="mic" size={24}/>
                                        <span className="text-[10px] md:text-base font-bold mt-1 md:mt-0">å¬è¯»éŸ³</span>
                                    </button>
                                    <button onClick={handleExplain} disabled={aiStatus==='loading'} className="flex flex-col md:flex-row items-center justify-center md:gap-3 h-16 md:h-20 bg-indigo-500 text-white rounded-2xl shadow-lg shadow-indigo-200 active:scale-95 transition-transform hover:bg-indigo-600">
                                        <Icon name="sparkles" size={24}/>
                                        <span className="text-[10px] md:text-base font-bold mt-1 md:mt-0">AIè®²è§£</span>
                                    </button>
                                    <button onClick={handleStartChat} className="flex flex-col md:flex-row items-center justify-center md:gap-3 h-16 md:h-20 bg-sky-500 text-white rounded-2xl shadow-lg shadow-sky-200 active:scale-95 transition-transform hover:bg-sky-600">
                                        <Icon name="chat" size={24}/>
                                        <span className="text-[10px] md:text-base font-bold mt-1 md:mt-0">èŠèŠå¤©</span>
                                    </button>
                                </div>
                            ) : null}

                            {/* Chat Interface */}
                            {chatMode && (
                                <div className="absolute inset-0 z-30 flex flex-col bg-white rounded-3xl shadow-xl overflow-hidden border border-sky-100 animate-in zoom-in-95 duration-200">
                                    <div className="bg-sky-50 p-3 flex justify-between items-center border-b border-sky-100">
                                        <div className="flex items-center gap-2 text-sky-600 font-bold">
                                            <div className="w-8 h-8 bg-sky-200 rounded-full flex items-center justify-center text-white">ğŸ¤–</div>
                                            æˆ‘æ˜¯â€œ{cards[curIdx].hanzi}â€
                                        </div>
                                        <button onClick={()=>setChatMode(false)} className="text-slate-400 hover:text-red-500 p-1"><Icon name="x" size={20}/></button>
                                    </div>
                                    <div className="flex-1 overflow-y-auto p-4 space-y-3 bg-slate-50" ref={chatBoxRef}>
                                        {chatHistory.map((msg, i) => (
                                            <div key={i} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                                                <div className={`max-w-[80%] p-3 rounded-2xl text-sm leading-relaxed ${msg.role === 'user' ? 'bg-sky-500 text-white rounded-tr-none' : 'bg-white text-slate-700 shadow-sm rounded-tl-none border border-slate-100'}`}>
                                                    {msg.loading ? <span className="animate-pulse">...</span> : msg.content}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="p-2 bg-white border-t flex gap-2 items-center">
                                        <button 
                                            onClick={toggleVoiceInput}
                                            className={`p-3 rounded-xl flex items-center justify-center transition-all ${isRecording ? 'bg-red-500 text-white mic-active shadow-red-300 shadow-lg' : 'bg-slate-100 text-slate-400 hover:bg-slate-200'}`}
                                        >
                                            <Icon name="mic" size={20}/>
                                        </button>
                                        <input 
                                            value={chatInput} 
                                            onChange={e=>setChatInput(e.target.value)} 
                                            onKeyDown={e=>e.key==='Enter'&&handleSendMessage()}
                                            placeholder={isRecording ? "æ­£åœ¨å¬ä½ è¯´..." : "æ‰“å­—æˆ–æŒ‰è¯­éŸ³..."}
                                            className={`flex-1 bg-slate-100 rounded-xl px-4 py-2 text-sm outline-none focus:ring-2 transition-all ${isRecording ? 'ring-2 ring-red-200 bg-red-50 placeholder-red-400' : 'ring-sky-200'}`}
                                        />
                                        <button onClick={handleSendMessage} className="bg-sky-500 text-white px-4 py-2 rounded-xl font-bold text-sm active:scale-95 shadow-md shadow-sky-200">å‘é€</button>
                                    </div>
                                </div>
                            )}

                            {/* AI Result Area (Desktop: Takes remaining height; Mobile: Overlay at bottom) */}
                            <div className={`
                                ${aiResult && !chatMode ? 'opacity-100 scale-100' : 'opacity-0 scale-95 pointer-events-none hidden'}
                                transition-all duration-300 ease-out origin-bottom md:origin-top
                                fixed bottom-0 left-0 right-0 md:static md:w-full md:flex-1
                                bg-white/95 backdrop-blur md:bg-white md:backdrop-blur-none
                                p-5 md:p-6 rounded-t-3xl md:rounded-3xl border-t md:border border-orange-100 md:shadow-sm
                                z-50 md:z-0 max-h-[60vh] md:max-h-none overflow-y-auto
                            `}>
                                <div className="flex justify-between items-center mb-3 sticky top-0 bg-white/95 py-2 border-b border-slate-100">
                                    <span className="text-orange-500 font-bold flex items-center gap-2 text-lg">
                                        <Icon name="brain" size={20}/> 
                                        AI è€å¸ˆè¯´
                                    </span>
                                    <button onClick={()=>setAiResult('')} className="w-8 h-8 flex items-center justify-center bg-slate-100 rounded-full text-slate-400 hover:bg-slate-200 hover:text-slate-600 transition-colors">Ã—</button>
                                </div>
                                <div className="text-sm md:text-base leading-relaxed text-slate-600 font-medium space-y-2 pb-8 md:pb-0" dangerouslySetInnerHTML={{__html: aiResult}}></div>
                            </div>
                            
                            {/* Empty State for Desktop (Placeholder) */}
                            {!aiResult && !chatMode && (
                                <div className="hidden md:flex flex-1 bg-white/50 border-2 border-dashed border-slate-200 rounded-3xl items-center justify-center text-slate-300 flex-col gap-2">
                                    <Icon name="sparkles" size={32} className="opacity-50"/>
                                    <p className="text-sm font-bold">ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹å­¦ä¹ </p>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        // --- å¬å†™æ¨¡å¼ (å·²ä¿®å¤è¿è¯»Bugï¼Œå¹¶ä¼˜åŒ–é¦–å­—å‘éŸ³) ---
        function DictationMode({ callGemini, addStar, voiceURI, onBack }) {
            const [words, setWords] = useState(() => JSON.parse(localStorage.getItem('dictation_words')) || ["æ— è®º", "èˆ¹èˆ±"]);
            const [idx, setIdx] = useState(0);
            const [status, setStatus] = useState('idle');
            const [feedback, setFeedback] = useState('');
            const [showHint, setShowHint] = useState(false);
            const [hintCount, setHintCount] = useState(0); // è®°å½•æŸ¥çœ‹æ¬¡æ•°
            const recognitionRef = useRef(null);
            
            // ä¿®å¤è¿è¯» Bug æ ¸å¿ƒé€»è¾‘ï¼šä½¿ç”¨ autoPlayRef æ¥æ§åˆ¶ç¿»é¡µåçš„æ’­æ”¾
            const autoPlayRef = useRef(false);
            const timerRef = useRef(null);
            const hintTimerRef = useRef(null);

            useEffect(() => localStorage.setItem('dictation_words', JSON.stringify(words)), [words]);

            const stopEverything = () => {
                if(timerRef.current) { clearTimeout(timerRef.current); timerRef.current = null; }
                if(hintTimerRef.current) { clearTimeout(hintTimerRef.current); hintTimerRef.current = null; }
                if(window.responsiveVoice) { window.responsiveVoice.cancel(); }
                if('speechSynthesis' in window) { window.speechSynthesis.cancel(); }
            };

            // æ–°å¢ï¼šå…¨å±è§¦æ§å”¤é†’ (æç®€ç‰ˆ)
            // ä¸“é—¨è§£å†³ iOS è‡ªåŠ¨æ–­å¼€åæ— æ³•é‡è¿çš„é—®é¢˜
            const handleTouchWake = () => {
                // åªæœ‰åœ¨ç­‰å¾…æŒ‡ä»¤(listening)æ—¶æ‰å“åº”ï¼Œé˜²æ­¢è¯¯è§¦
                if (status === 'listening' && recognitionRef.current) {
                    try { 
                        // å°è¯•å¯åŠ¨ã€‚å¦‚æœå·²ç»åœ¨è·‘ï¼Œæµè§ˆå™¨ä¼šæŠ¥é”™ä½†æ— å®³ï¼›å¦‚æœåœäº†ï¼Œè¿™å¥å°±èƒ½æ•‘æ´»å®ƒã€‚
                        recognitionRef.current.start(); 
                        console.log("ğŸ‘† è§¦æ‘¸å”¤é†’å½•éŸ³æœº");
                    } catch(e) {
                        // å¦‚æœ start æŠ¥é”™ï¼ˆæ¯”å¦‚å·²ç»åœ¨è¿è¡Œï¼‰ï¼Œæˆ‘ä»¬å¿½ç•¥å®ƒï¼Œä¸å½±å“æµç¨‹
                    }
                }
            };

            // ç›‘å¬ idx å˜åŒ–ï¼Œå¤„ç†è‡ªåŠ¨è¿è¯»ï¼Œå¹¶é‡ç½®çœ‹ä¸€çœ¼æ¬¡æ•°
            useEffect(() => {
                setHintCount(0);
                if (autoPlayRef.current) {
                    autoPlayRef.current = false;
                    // å»¶è¿Ÿä¸€ç‚¹æ’­æ”¾ï¼Œä½“éªŒæ›´å¥½ï¼Œä¸”é¿å¼€ useEffect cleanup çš„æ‰“æ–­
                    timerRef.current = setTimeout(() => startPlay(words[idx]), 500);
                }
            }, [idx, words]);

            useEffect(() => {
                if ('webkitSpeechRecognition' in window) {
                    const r = new webkitSpeechRecognition();
                    r.continuous = false; r.lang = 'zh-CN';
                    r.onend = () => {};
                    r.onresult = (e) => {
                        const cmd = e.results[0][0].transcript;
                        if (cmd.match(/ä¸‹|è¿‡|å¥½|ok/i)) goNext();
                        else if (cmd.match(/é‡|å†|å¬/)) startPlay(words[idx]);
                        else if (cmd.match(/ç¬”|çœ‹/)) setShowHint(p => !p);
                    };
                    recognitionRef.current = r;
                }
                return () => { stopEverything(); if(recognitionRef.current) recognitionRef.current.stop(); };
            }, [words, idx]);

            const startPlay = (wordToPlay) => { 
                stopEverything(); 
                setStatus('playing'); setShowHint(false); 
                
                let delay = 100; // é»˜è®¤æé€Ÿå¯åŠ¨
                
                // ä»…å½“åˆšæ‰åœ¨å½•éŸ³(recognitionå­˜åœ¨)æ—¶ï¼Œæ‰éœ€è¦ 1200ms çš„é•¿å†·å´
                // è¿™æ ·ç¬¬ä¸€æ¬¡æ’­æ”¾å°±æ˜¯ç§’å¼€ï¼Œåªæœ‰åˆ‡è¯æ—¶æ‰ç­‰å¾…
                if (recognitionRef.current) {
                    try { recognitionRef.current.abort(); } catch(e){}
                    delay = 1200;
                }

                setTimeout(() => speakLoop(wordToPlay || words[idxRef.current], 1), delay);
            };

            const speakLoop = (text, count) => {
                // è¯»å®Œ3éåï¼Œå°è¯•è‡ªåŠ¨è¿›å…¥ç›‘å¬çŠ¶æ€
                if(count > 3) { 
                    setStatus('listening'); 
                    
                    // âš ï¸ è‡ªåŠ¨é‡å¯å½•éŸ³æœº (Auto-Start)
                    // åœ¨ iOS ä¸Šï¼Œå¦‚æœåœ¨æ’­æ”¾åˆšç»“æŸæ—¶ç«‹åˆ» startï¼Œä¼šè¢«æ‹¦æˆªã€‚
                    // ç­–ç•¥ï¼šç­‰å¾… 1000ms è®©æ’­æ”¾å™¨å½»åº•é‡Šæ”¾ï¼Œç„¶åå†è¯•æ¢æ€§å¯åŠ¨ã€‚
                    // å¦‚æœè¿™æ‹›å¥æ•ˆï¼Œå°±èƒ½å®ç°â€œå…¨è‡ªåŠ¨â€ï¼›å¦‚æœä¸è¡Œï¼Œç”¨æˆ·è¿˜å¯ä»¥æ‹å±å¹•ã€‚
                    setTimeout(() => {
                        try{ if(recognitionRef.current) recognitionRef.current.start(); } catch(e){}
                    }, 1000);
                    
                    return; 
                }
                // ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„ voiceURIï¼Œå¦‚æœæ²¡æœ‰åˆ™æ™ºèƒ½é€‰æ‹©
                playAudio(text, voiceURI); 
                // å€’è®¡æ—¶è¯»ä¸‹ä¸€é
                timerRef.current = setTimeout(() => speakLoop(text, count + 1), 2500);
            };

            const goNext = () => { 
                if(idx < words.length - 1) { 
                    stopEverything(); // å…ˆåœæ­¢å½“å‰çš„
                    setIdx(prev => prev + 1); // åˆ‡æ¢ç´¢å¼•
                    setStatus('idle'); 
                    setFeedback(''); 
                    autoPlayRef.current = true; // æ ‡è®°ç¿»é¡µåè‡ªåŠ¨æ’­æ”¾
                } else alert("å®Œæˆï¼"); 
            };
            
            const handleCheck = async (e) => {
                const file = e.target.files[0]; if(!file) return;
                setStatus('grading'); setFeedback('ğŸ‘€ æ‰¹æ”¹ä¸­...');
                const base64 = await compressImage(file);
                const res = await callGemini({ contents: [{ parts: [{ text: `æ£€æŸ¥ä½œä¸šæ˜¯å¦åŒ…å«"${words[idx]}"ã€‚æ¸©æŸ”ç‚¹è¯„ã€‚` }, { inlineData: { mimeType: "image/jpeg", data: base64 } }] }] });
                setStatus('listening');
                if(res.text) { setFeedback(res.text); playAudio(res.text); addStar(); }
            };

            const handlePhotoImportWords = async (e) => {
                const file = e.target.files[0]; if(!file) return;
                const base64 = await compressImage(file);
                setStatus('grading'); setFeedback('ğŸ” æ­£åœ¨æå–è¯è¯­...');
                
                const prompt = `æå–å›¾ç‰‡ä¸­æ‰€æœ‰çš„ä¸­æ–‡è¯è¯­ï¼ˆä¾‹å¦‚ï¼šæ˜¥å¤©ã€æ— è®ºã€å¼€å¿ƒï¼‰ã€‚è¯·å¿½ç•¥å•çº¯çš„é¡µç ã€æ ‡é¢˜æˆ–æ— å…³æ–‡å­—ã€‚è¯·è¿”å› JSON å­—ç¬¦ä¸²æ•°ç»„ï¼Œä¾‹å¦‚: ["è¯è¯­1", "è¯è¯­2"]`;

                const res = await callGemini({ contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: "image/jpeg", data: base64 } }] }] });
                
                try {
                    const cleanJson = res.text.replace(/```json|```/g, '').trim();
                    const list = JSON.parse(cleanJson);
                    
                    if (Array.isArray(list) && list.length > 0) {
                        const newWords = list.filter(w => !words.includes(w));
                        if(newWords.length > 0) {
                            if(confirm(`è¯†åˆ«åˆ° ${list.length} ä¸ªè¯ï¼Œå…¶ä¸­ ${newWords.length} ä¸ªæ˜¯æ–°çš„ã€‚\nè¦æ·»åŠ åˆ°å½“å‰åˆ—è¡¨å—ï¼Ÿ(ç‚¹å‡»å–æ¶ˆåˆ™è¦†ç›–å½“å‰åˆ—è¡¨)`)) {
                                setWords([...words, ...newWords]);
                            } else {
                                setWords(list); 
                                setIdx(0);
                            }
                            alert("âœ… è¯åº“å¯¼å…¥æˆåŠŸï¼");
                        } else { alert("è¯è¯­éƒ½é‡å¤äº†ï¼Œæ— éœ€æ·»åŠ ã€‚"); }
                    } else { alert("æ²¡æ‰¾åˆ°åˆé€‚çš„è¯è¯­ã€‚"); }
                } catch(e) { alert("è¯†åˆ«å¤±è´¥"); }
                setStatus('idle'); setFeedback('');
            };

            const handleImport = () => {
                const text = prompt("è¾“å…¥æ–°è¯åº“ï¼ˆç”¨ç©ºæ ¼åˆ†éš”ï¼‰ï¼š", words.join(" "));
                if(text) {
                    const list = text.split(/[\s,ï¼Œ]+/).filter(w=>w.trim());
                    const uniqueList = [...new Set(list)];
                    if(uniqueList.length) { 
                        setWords(uniqueList); 
                        setIdx(0); 
                        alert(`å·²å¯¼å…¥ ${uniqueList.length} ä¸ªè¯`); 
                    }
                }
            };

            return (
                <div 
                    className="h-full flex flex-col p-4 bg-slate-50 relative"
                    onClick={handleTouchWake} // ç»‘å®šå…¨å±ç‚¹å‡»
                >
                    <div className="flex justify-between items-center mb-6">
                        <button onClick={onBack} className="text-slate-400 font-bold"><Icon name="arrowLeft" size={20}/></button>
                        <div className="text-slate-500 font-bold">å¬å†™: ç¬¬ {idx+1}/{words.length} ä¸ª</div>
                    </div>

                    <div className="flex-1 flex flex-col items-center pt-8">
                        <div className="flex flex-wrap justify-center gap-3 mb-8">
                            {words[idx].split('').map((char, i) => (
                                <div key={i} className="tian-zi-ge w-28 h-28 sm:w-32 sm:h-32 flex items-center justify-center shadow-sm">
                                    <span className={`tian-zi-ge-content font-kaiti text-7xl text-slate-800 transition-opacity duration-300 ${showHint ? 'opacity-30' : 'opacity-0'}`}>
                                        {char}
                                    </span>
                                </div>
                            ))}
                        </div>

                        <div className="flex flex-col items-center gap-2 h-20">
                            {status === 'playing' && <div className="text-orange-500 font-bold animate-pulse">æ­£åœ¨è¯»...</div>}
                            {status === 'listening' && (
                                <div className="flex flex-col items-center gap-2 animate-in zoom-in">
                                    <div className="text-green-600 font-bold bg-green-50 px-4 py-2 rounded-full border border-green-200 flex items-center gap-2 shadow-sm">
                                        <div className="w-3 h-3 bg-green-500 rounded-full mic-active"></div>
                                        è¯·ä¹¦å†™ (å–Š: ä¸‹ä¸€ä¸ª)
                                    </div>
                                    <div className="text-xs text-slate-400">ğŸ‘† iOSå¦‚æœä¸çµï¼Œè¯·æ‹ä¸€ä¸‹å±å¹•å†å–Š</div>
                                </div>
                            )}
                            {status === 'grading' && <div className="text-indigo-500 font-bold animate-bounce">ğŸ¤– æ­£åœ¨æ‰¹æ”¹...</div>}
                            {status === 'idle' && <div className="text-slate-400 text-sm">å‡†å¤‡å¼€å§‹</div>}
                        </div>
                        {feedback && <div className="bg-white p-4 rounded-xl shadow border-l-4 border-orange-400 mt-4 text-sm text-slate-600 animate-in slide-in-from-bottom-2">{feedback}</div>}
                    </div>

                    <div className="mt-auto grid grid-cols-2 gap-3 pb-6 relative z-10"> {/* åº•éƒ¨æŒ‰é’®åŒº */}
                        {status === 'idle' ? 
                            <button onClick={() => startPlay(words[idx])} className="col-span-2 bg-orange-500 text-white py-4 rounded-2xl shadow-lg font-bold text-lg active:scale-95 transition-transform">â–¶ å¼€å§‹</button> :
                            <>
                                <button onClick={() => startPlay(words[idx])} className="bg-white text-orange-500 border-2 border-orange-100 py-3 rounded-xl font-bold active:scale-95">â†º é‡è¯»</button>
                                <label className="bg-indigo-500 text-white py-3 rounded-xl font-bold shadow-lg flex items-center justify-center gap-2 cursor-pointer active:scale-95"><Icon name="camera" size={20}/> æ‰¹æ”¹<input type="file" className="hidden" accept="image/*" onChange={handleCheck} /></label>
                                <button onClick={() => {
                                    if(showHint) { setShowHint(false); if(hintTimerRef.current) clearTimeout(hintTimerRef.current); }
                                    else { 
                                        setShowHint(true); 
                                        const duration = hintCount === 0 ? 3000 : 1000;
                                        hintTimerRef.current = setTimeout(() => setShowHint(false), duration);
                                        setHintCount(c => c + 1);
                                    }
                                }} className="col-span-2 bg-slate-100 text-slate-500 py-3 rounded-xl font-bold active:scale-95">{showHint?'éšè—': (hintCount===0 ? 'çœ‹ä¸€çœ¼ (3ç§’)' : 'çœ‹ä¸€çœ¼ (1ç§’)')}</button>
                                <button onClick={goNext} className="col-span-2 bg-green-500 text-white py-3 rounded-xl font-bold shadow-lg active:scale-95">ä¸‹ä¸€ä¸ª â­</button>
                            </>
                        }
                        
                        <div className="col-span-2 flex justify-center gap-4 mt-2 text-xs text-slate-400">
                            <label className="cursor-pointer hover:text-orange-500 flex items-center gap-1">
                                <Icon name="camera" size={14}/> æ‹ç…§å¯¼å…¥è¯åº“
                                <input type="file" className="hidden" accept="image/*" onChange={handlePhotoImportWords} />
                            </label>
                            <span className="text-slate-300">|</span>
                            <button onClick={handleImport} className="hover:text-orange-500">æ‰‹åŠ¨ç¼–è¾‘</button>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"d4d21f425d6c4eea9650e34329415612","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>